## mysql基本概念

### 事务的标准特征

> 事务（Transaction）是并发控制的单位，是用户定义的一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位。 

- 原子性(Atomicity)

  事务是数据库的逻辑工作单位，事务中包括的诸操作要么全做，要么全不做。
  事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

- 一致性(Consistency)

  事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。
  一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。
  也就是说：如果事务是并发多个，系统也必须如同串行事务一样操作。其主要特征是保护性和不变性(Preserving an Invariant).
  以转账案例为例，假设有五个账户，每个账户余额是100元，那么五个账户总额是500元，如果在这个5个账户之间同时发生多个转账，无论并发多少个，
  比如在A与B账户之间转账5元，在C与D账户之间转账10元，在B与E之间转账15元，五个账户总额也应该还是500元，这就是保护性和不变性.

- 隔离性(Isolation)

  一个事务的执行不能被其他事务干扰。隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，
  执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，
  必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。

- 持续性/永久性(Durability)

   一个事务一旦提交，它对数据库中数据的改变就应该是永久性的,不会被回滚。

### 隔离级别

- read  uncommitted（读未提交）

  读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。

  事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。

- read committed（读已提交）

  读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。

  一个事务只能读取数据库中已经提交过的数据，解决了脏读问题，但不能重复读，即一个事务内的两次查询返回的数据是不一样的。如第一次查询金额是100，第二次去查询可能就是50了，这就是不可重复读取

- repetable read（可重复读）

  可重复读取数据，这也是Mysql默认的隔离级别

  一个事务内的两次无锁查询返回的数据都是一样的，但别的事务的新增数据也能读取到。比如另一个事务插入了一条数据并提交，这个事务第二次去读取的时候发现多了一条之前查询数据列表里面不存在的数据，这时候就是传说的中幻读了。这个级别避免了不可重复读取，但不能避免幻读的问题。

- serializable(可串行化) 

  可串行化读

  这是效率最低最耗费资源的一个事务级别，和可重复读类似，但在自动提交模式关闭情况下可串行化读会给每个查询加上共享锁和排他锁，意味着所有的读操作之间不阻塞，但读操作会阻塞别的事务的写操作，写操作也阻塞读操作。

### 数据库三范式

- 第一范式：属性不可拆分

   如：地址这个属性是可拆分成城市地区等等，不可以把地址作为一个属性<br >     解决方案：属性拆分开来，将一个地址属性改成多个属性，按照城市地区..设置多个属性。<br>

- 第二范式：如果依赖于主键，则需要依赖于所有主键，不能存在依赖部分主键的情况

  简单点说，就是不要把不相关的东西放到一个表里面。

- 第三范式：一个数据库表中不包含已在其它表中已包含的非主关键字信息

  不得存在传递式依赖，比如对于一张数据库，里面的元素有son, person, father, grand-father，依赖关系是son -> person, person -> father, father -> grand-father，明显有一个链表式的传递，3NF中禁止此类依赖的出现

[如何解释关系数据库的第一第二第三范式](https://www.zhihu.com/question/24696366)

