## 消息队列

>以提出问题的方式作为学习消息队列中间件

#### 1，为什么使用消息队列（解耦，限流，异步）

- 业务中存在模块与模块之间的交互，通过消息队列能降低模块之间的耦合性，
- 短时间大量的请求可能会冲垮服务器，可以堆积到队列上在进行处理
- 当一个请求需要处理的逻辑比较多，而之间没有必须的前后顺序，可以进行异步处理通过发送到队列是对应的模块处理

#### 2，消息队列有什么优缺点

- 系统的可用性降低 一旦mq宕机那么整个系统流程就出问题了
- 系统复杂度提高，需要考虑消息的重复消费或者是否确认消费
- 一致性问题，模块之间处理数据，如何保证一致性

#### 3，为什么使用RabbitMq

- 微秒级，这是 RabbitMQ 的一大特点，延迟最低
- 基于 erlang 开发，并发能力很强，性能极好，延时很低
- 可视化界面

#### 4, 如何保证消息队列的高可用

- 集群部署

#### 5，如何保证消息的可靠性传输

- 生产者： 开启Confirm模式（异步，推荐）
- MQ: 开启RabbitMQ持久化
- 消费者：关闭RabbitMq自动Ack，开启手动ACK

#### 6,  如何保证消费的顺序性

拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。 

#### 7，[如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fdoocs%2Fadvanced-java%2Fblob%2Fmaster%2Fdocs%2Fhigh-concurrency%2Fmq-time-delay-and-expired-failure.md)

- 新开多个队列，多个消费者快速消费
- 手动查询丢失数据，重新入队列











